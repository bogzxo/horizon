#version 460 core
layout (local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

struct DrawElementsIndirectCommand {
    uint Count;
    uint InstanceCount;
    uint FirstIndex;
    int FirstVertex;
    uint BaseInstance;
    
    // Center of the chunk
    int ChunkCenterX;
    int ChunkCenterY;
    uint spacer;
};

// Array containing indirect draw calls
layout (std430, binding = 0) buffer b_indirectBlock {
    DrawElementsIndirectCommand cmds[];
};

layout (std430, binding = 1) buffer b_visibilityBuffer {
    int visibility[];
};

// layout (std430, binding = 2) buffer b_cullIndirectBlock {
//     DrawElementsIndirectCommand cullCmds[];
// };

// Uniforms
uniform mat4 uProj;
uniform mat4 uView;
uniform vec3 uCamDir;

uniform int uWorldWidth;
uniform uint uTileChunkCount;
uniform bool uCullFaces;

struct chunkOffset {
    int xPos;
    int zPos;
    int face;
    bool visible;
};

bool pointInFrustum(vec3 p) {
    vec4 Pclip = uProj * uView * vec4(p, 1.0);
    return all(lessThan(abs(Pclip.xy), vec2(Pclip.w))) && Pclip.z > 0.0 && Pclip.z < Pclip.w;
}
vec3 cornerOffsets[8] = vec3[](
    vec3(16, 16, 16), vec3(-16, 16, 16), vec3(16, -16, 16), vec3(-16, -16, 16),
    vec3(16, 16, -16), vec3(-16, 16, -16), vec3(16, -16, -16), vec3(-16, -16, -16));

bool chunkInFrustum(vec3 p) {
    for (int i = 0; i < 8; ++i) {
        if (pointInFrustum(p + cornerOffsets[i])) {
            return true;
        }
    }
    return false;
}

vec3 faceToDirection[6] = vec3[](vec3(0, -1, 0), vec3(0, 1, 0), vec3(0, 0, -1), vec3(0, 0, 1), vec3(-1, 0, 0), vec3(1, 0, 0));

void main() {
    // calcualte index from global id
    uint index = gl_GlobalInvocationID.x * 6;
    
    // check bounds
    if (index >= uTileChunkCount) return;
    
    // Then cull voxel faces that are facing away from the camera
    for (uint i = 0; i < 6; i++) {
        cmds[index + i].InstanceCount = dot(uCamDir, faceToDirection[i]) > -0.7 ? 1 : 0;
    }
    
    if (visibility[index] == 0) {
        cmds[index + 0].InstanceCount = 0;
        cmds[index + 1].InstanceCount = 0;
        cmds[index + 2].InstanceCount = 0;
        cmds[index + 3].InstanceCount = 0;
        cmds[index + 4].InstanceCount = 0;
        cmds[index + 5].InstanceCount = 0;
        return;
    }
    
    // Skip face culling if not required
    if (!uCullFaces) return;
    
    // if (!chunkInFrustum(vec3(cmds[index].ChunkCenterX, 0, cmds[index].ChunkCenterY))) {
    //     cmds[index + 0].InstanceCount = 0;
    //     cmds[index + 1].InstanceCount = 0;
    //     cmds[index + 2].InstanceCount = 0;
    //     cmds[index + 3].InstanceCount = 0;
    //     cmds[index + 4].InstanceCount = 0;
    //     cmds[index + 5].InstanceCount = 0;
    // }
}
