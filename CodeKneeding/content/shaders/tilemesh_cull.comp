#version 460 core
layout (local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

#include "chunkmesh_common.h"

layout (std430, binding = 0) buffer b_indirectBlock {
    DrawElementsIndirectCommand cmds[];
};

layout (std430, binding = 1) coherent readonly buffer b_visibilityBuffer {
    int visibility[];
};

layout (std430, binding = 2) coherent buffer b_finalIndirectBlock {
    uint drawCount;
    DrawElementsIndirectCommand realCmds[];
};

layout (std430, binding = 3) coherent writeonly buffer b_chunkPosDataIndicies {
    uint[] indexMap;
};

uniform vec3 uCamDir;
uniform uint uTileChunkCount;
uniform bool uCullFaces;

vec3 faceToDirection[6] = vec3[](vec3(0, -1, 0), vec3(0, 1, 0), vec3(0, 0, -1), vec3(0, 0, 1), vec3(-1, 0, 0), vec3(1, 0, 0));

void main() {
    // calcualte index from global id
    uint index = gl_GlobalInvocationID.x * 6;
    
    // check bounds
    if (gl_GlobalInvocationID.x >= uTileChunkCount) return;
    
    if (gl_GlobalInvocationID.x == 0) {
        drawCount = 0;
    }
    
    for (uint i = 0; i < 6; i++) {
        uint iindex = index + i;
        if ((dot(uCamDir, faceToDirection[i]) > -0.8 && visibility[iindex] == 1)) {
            uint currentDrawCount = atomicAdd(drawCount, 1);
            realCmds[currentDrawCount] = cmds[iindex];
            indexMap[currentDrawCount] = iindex;
        }
    }
}
