#version 460 core
layout (local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

#include "chunkmesh_common.h"

layout (std430, binding = 0) buffer b_indirectBlock {
    DrawElementsIndirectCommand cmds[];
};

uniform mat4 uProj;
uniform mat4 uView;

uniform uint uTileChunkCount;

bool pointInFrustum(vec3 p) {
    vec4 Pclip = uProj * uView * vec4(p, 1.0);
    return all(lessThan(abs(Pclip.xy), vec2(Pclip.w))) && Pclip.z > 0.0 && Pclip.z < Pclip.w;
}
vec3 cornerOffsets[8] = vec3[](
    vec3(16, 16, 16), vec3(-16, 16, 16), vec3(16, -16, 16), vec3(-16, -16, 16),
    vec3(16, 16, -16), vec3(-16, 16, -16), vec3(16, -16, -16), vec3(-16, -16, -16));

bool chunkInFrustum(vec3 p) {
    for (int i = 0; i < 8; ++i) {
        if (pointInFrustum(p + cornerOffsets[i])) {
            return true;
        }
    }
    return false;
}

void main() {
    // calcualte index from global id
    uint index = gl_GlobalInvocationID.x * 6;
    
    // check bounds
    if (gl_GlobalInvocationID.x >= uTileChunkCount) return;
    
    if (!chunkInFrustum(vec3(cmds[index].ChunkCenterX, cmds[index].ChunkCenterY, cmds[index].ChunkCenterZ))) {
        cmds[index + 0].InstanceCount = 0;
        cmds[index + 1].InstanceCount = 0;
        cmds[index + 2].InstanceCount = 0;
        cmds[index + 3].InstanceCount = 0;
        cmds[index + 4].InstanceCount = 0;
        cmds[index + 5].InstanceCount = 0;
    }
    else {
        cmds[index + 0].InstanceCount = 1;
        cmds[index + 1].InstanceCount = 1;
        cmds[index + 2].InstanceCount = 1;
        cmds[index + 3].InstanceCount = 1;
        cmds[index + 4].InstanceCount = 1;
        cmds[index + 5].InstanceCount = 1;
    }
}
