#version 460 core
layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

struct DrawElementsIndirectCommand {
    uint Count;
    uint InstanceCount;
    uint FirstIndex;
    uint BaseInstance;
    
    // Original instance count
    uint BaseInstanceCount;
    
    // Center of the chunk
    int ChunkCenterX;
    int ChunkCenterY;
    int spacer;
};

// Uniforms
uniform mat4 uProj;
uniform mat4 uView;
uniform vec3 uCamDir;

uniform int uWorldWidth;
uniform uint uTileChunkCount;
uniform bool uCullFaces;

// Array containing indirect draw calls
layout (std430, binding = 0) buffer IndirectBlock {
    DrawElementsIndirectCommand cmds[];
};

bool pointInFrustum(vec3 p) {
    vec4 Pclip = uProj * uView * vec4(p, 1.0);
    return all(lessThan(abs(Pclip.xy), vec2(Pclip.w))) && Pclip.z > 0.0 && Pclip.z < Pclip.w;
}
vec3 cornerOffsets[8] = vec3[](
    vec3(16, 16, 16), vec3(-16, 16, 16), vec3(16, -16, 16), vec3(-16, -16, 16),
    vec3(16, 16, -16), vec3(-16, 16, -16), vec3(16, -16, -16), vec3(-16, -16, -16));

bool chunkInFrustum(vec3 p) {
    for (int i = 0; i < 8; ++i) {
        if (pointInFrustum(p + cornerOffsets[i])) {
            return true;
        }
    }
    return false;
}

vec3 faceToDirection[6] = vec3[](vec3(0, -1, 0), vec3(0, 1, 0), vec3(0, 0, -1), vec3(0, 0, 1), vec3(-1, 0, 0), vec3(1, 0, 0));

void main() {
    // calcualte index from global id
    uint index = (gl_GlobalInvocationID.x + gl_GlobalInvocationID.z * uWorldWidth) * 6;
    
    // check bounds
    if (index >= uTileChunkCount) return;
    
    // first try cull the entire chunk
    if (!chunkInFrustum(vec3(cmds[index].ChunkCenterX, 0, cmds[index].ChunkCenterY))) {
        cmds[index + 0].InstanceCount = 0;
        cmds[index + 1].InstanceCount = 0;
        cmds[index + 2].InstanceCount = 0;
        cmds[index + 3].InstanceCount = 0;
        cmds[index + 4].InstanceCount = 0;
        cmds[index + 5].InstanceCount = 0;
        return;
    }
    
    // Skip face culling if not required
    if (!uCullFaces) return;
    
    // then cull voxel faces that are facing away from the camera
    for (uint i = 0; i < 6; i++) {
        cmds[index + i].InstanceCount = dot(uCamDir, faceToDirection[i]) > -0.7 ? cmds[index + i].BaseInstanceCount : 0;
    }
}
